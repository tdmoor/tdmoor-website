<!DOCTYPE html><!-- Last Published: Tue Mar 30 2021 10:53:00 GMT+0000 (Coordinated Universal Time) --><html data-wf-domain="www.tdmoor.com" data-wf-page="5e909d68426ccc2412459791" data-wf-site="5e849171e22116b8b837e679"><head><meta charset="utf-8"/><title>The Byzantine Generals Problem in Blockchain</title><meta content="This article will explain what Byzantine fault tolerance is, dive into the Two Generals Problem and the Byzantine Generals Problem, and show how different blockchains solve the difficult problem of finding agreement in a decentralized system." name="description"/><meta content="The Byzantine Generals Problem in Blockchain" property="og:title"/><meta content="This article will explain what Byzantine fault tolerance is, dive into the Two Generals Problem and the Byzantine Generals Problem, and show how different blockchains solve the difficult problem of finding agreement in a decentralized system." property="og:description"/><meta content="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb3f2cbd2a1d58eaee9fe_Trust.jpg" property="og:image"/><meta content="The Byzantine Generals Problem in Blockchain" property="twitter:title"/><meta content="This article will explain what Byzantine fault tolerance is, dive into the Two Generals Problem and the Byzantine Generals Problem, and show how different blockchains solve the difficult problem of finding agreement in a decentralized system." property="twitter:description"/><meta content="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb3f2cbd2a1d58eaee9fe_Trust.jpg" property="twitter:image"/><meta property="og:type" content="website"/><meta content="summary_large_image" name="twitter:card"/><meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="94QpIXZqFZhtMh9HCNtcJfLEc6eSKQGdLZQ_yh6ADTE" name="google-site-verification"/><link href="https://uploads-ssl.webflow.com/5e849171e22116b8b837e679/css/tdmoor.webflow.d5ccfccbc.min.css" rel="stylesheet" type="text/css"/><script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script><script type="text/javascript">WebFont.load({  google: {    families: ["Crimson Pro:200,300,regular,700,800,200italic,300italic","Muli:200,300,regular,700,800,200italic,300italic"]  }});</script><!--[if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" type="text/javascript"></script><![endif]--><script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script><link href="https://uploads-ssl.webflow.com/5e849171e22116b8b837e679/5e9c4b14b27cf659db9d2c68_Blockchain%20Marketer%20Favicon.png" rel="shortcut icon" type="image/x-icon"/><link href="https://uploads-ssl.webflow.com/5e849171e22116b8b837e679/5e9c4af4b27cf60e059d2b93_Blockchain%20Marketer%20Logo.png" rel="apple-touch-icon"/><link href="https://tdmoor.com/blog/byzantine-generals-problem-in-blockchain" rel="canonical"/><link href="rss.xml" rel="alternate" title="RSS Feed" type="application/rss+xml"/><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-55297344-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-55297344-4');
</script>

<meta name="p:domain_verify" content="b95fc6dea279ad8842804beb65b2a7fe"/></head><body><div class="background-wrapper"><div data-collapse="none" data-animation="default" data-duration="400" role="banner" class="navbar w-nav"><a href="/" class="brand w-nav-brand"><div class="text-block">Thomas De Moor</div></a><nav role="navigation" class="nav-menu w-nav-menu"><a href="/about" class="nav-link w-nav-link">About</a><a href="/blog" class="nav-link w-nav-link">Blog</a><a href="/contact" class="nav-link w-nav-link">Contact</a><a href="https://twitter.com/ThDeM" target="_blank" class="nav-link w-nav-link">Twitter</a></nav></div><div class="heading-wrapper"><div class="div-block blog"><div style="background-color:#eac435" class="tag blog">blockchain</div></div><h1 class="heading">The Byzantine Generals Problem in Blockchain</h1></div><div class="main-wrapper"><div class="rich-text-block w-richtext"><p>Satoshi Nakamoto had a vision. He wanted to create a transparent financial system that wouldn’t require the help of the financial institutions that had served as “<a href="https://www.icij.org/investigations/fincen-files/" target="_blank">trusted</a>” third parties for centuries on end. Nakamoto didn’t want any middlemen at all. He wanted a system where anyone should be able to send money directly to someone else without any stops in between.<br/></p><p>This might sound like an easy thing to do, because we exchange money directly all the time with cash, but it’s in fact incredibly hard to do this digitally. Consider person A sending $10 to person B while at the same time sending that same $10 to person C. Impossible with cash, but very possible with digital money. This problem is called <a href="https://www.investopedia.com/terms/d/doublespending.asp" target="_blank">double spending</a>. <br/></p><p>It’s an easy enough problem to solve for centralized currencies, because financial institutions manage the flow of money and can block that $10 from going to person B or C. But double spending is a lot harder to solve if you want to build a financial system without middlemen. Who will stop the money from going to both B and C when there’s no one in between? <br/></p><p>Nakamoto proposed a decentralized system to solve this problem. A large group of people would independently look over all transactions and agree which transactions were legitimate and which were not.<br/></p><p>The real brilliance in Nakamoto’s proposal is <em>how</em> those people would agree. Remember, this is all done digitally. There’s no focus group sitting somewhere in Japan looking over all transactions. The people agreeing on transactions are scattered all over the world. In order to build a decentralized system that can sustainably and securely validate transactions, Nakamoto had to create something that was what’s called Byzantine fault tolerant.<br/></p><p>This article will explain what Byzantine fault tolerance is, dive into the Two Generals Problem and the Byzantine Generals Problem, and show how different blockchains (including Nakamoto’s Bitcoin) solve the difficult problem of finding agreement in a decentralized system.</p><h2>What is a Byzantine Fault?</h2><p>A <strong>Byzantine fault</strong> is any fault that causes parts of a system to receive different information while they should have received the same information. For example, node A wants to send (this) to node B and C, but a software bug causes it to send (this) to node B and (that) to node C. Or node A wants to send (this) to node B and C, but partial network failure causes it to send (this) to node B and nothing to node C (which it doesn’t see as an error, because receiving no response is also a possibility).<br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb28813fa858211fa7a92_HtWIUOPbJdYegK5RxKHX5o5o8Sgf8K1vckdHxt6FpXSRuA33SpvIa-rIkI-0N3uZOx-ik-YSlRXSDdijSdSbHwjLAdGbAd5IUb8BS3i48okneqT_64P4c84lELhQpWGOIMLfaV3U.jpeg" alt=""/></div><figcaption><em>A Byzantine fault can confuse a system</em></figcaption></figure><p>Byzantine faults are difficult to spot, because node A is still functional. It hasn’t shut down, it hasn’t produced any error, and the other nodes haven’t received any faulty input. So you wouldn’t know it’s not working as intended if you don’t look underneath the hood. Byzantine faults can do a lot of damage. They can cause a <strong>Byzantine failure</strong>, which happens when Byzantine faults cause the entire system - not just a particular node - to produce the wrong result.<br/></p><p><strong>Byzantine fault tolerance (BFT) </strong>is how well a system can tolerate these Byzantine faults. BFT is important in systems that need extreme reliability or where many different parts need to come to a consensus. Examples are the <a href="https://www.researchgate.net/publication/3922803_Safety_critical_avionics_for_the_777_primary_flight_controls_system" target="_blank">Boeing 777 flight control systems</a>, <a href="https://technology.nasa.gov/patent/LAR-TOPS-31" target="_blank">distributed clock synchronization systems</a>, as well as any blockchain.<br/></p><p>So how do you make a system Byzantine fault tolerant? Well, it depends on how many parts need to agree. This is where the problem of Byzantine faults splits in two: when there are two parts in the system and when there are many.</p><h2>The Two Generals Problem</h2><p>Aragorn and Boromir want to conquer the tower of Saruman. But Saruman is strong. Aragorn and Boromir can only defeat Saruman if they both attack at the same time. The problem is that the armies of Aragorn and Boromir are in two separate locations. They can only communicate by sending messengers through the territory of Saruman. <br/></p><p>This is problematic, because Saruman can intercept the messengers, kill them, change the content of their messages, send his own messengers, etc. How can either of our heroes reliably know when the other hero wants to attack? How can Aragorn and Boromir agree on when to attack Saruman? This is the so-called <strong>Two Generals Problem</strong>.<br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb2883c7462dc9c1548bc_2oTjbiOrIoBHZiwlbt9-uC27Ekd1p97cGRwhZth2UzkInTMEBnaKwt1jkiPU-5HCzCHAaeeUx6JFvD598U-B9qdBBHxX-E3t9sP1w4AWcY-DqDpgbblxmfWDPW5z5ZPp8mY8jgOB.jpeg" alt=""/></div><figcaption><em>Saruman sabotages their efforts to communicate</em></figcaption></figure><p>Sounds like a tough problem, doesn’t it? Computer scientists have tried solving it for decades. Akkoyunlu et al. were the first to mention this type of problem in their 1975 article <a href="https://dl.acm.org/doi/10.1145/800213.806523" target="_blank"><em>Some constraints and tradeoffs in the design of network communications</em></a>. As you can infer from the title of the article, they saw the problem as a constraint, a tradeoff, something you need to be aware of when designing a distributed system.<br/></p><p>And there is indeed no perfect solution to the Two Generals Problem. Aragorn and Boromir can never come to an agreement on when to attack if they would only use a single messenger. Even if the messenger safely arrives on the other end, they’ll never know for sure if Saruman corrupted its message or not. <br/></p><p>In the digital world, Aragorn and Boromir are computers and Saruman is the network between those computers. When the network is what’s causing Byzantine faults, it is impossible for the computers to find agreement. Fischer et al. proved this in their 1985 paper <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" target="_blank"><em>Impossibility of Distributed Consensus with One Faulty Process</em></a>.<br/></p><p>But there is a workaround. In reality, most networks aren’t fully Byzantine. They don’t corrupt all the messages all the time. They corrupt some of the messages some of the time. So there is a solution. Aragorn can send a hundred messengers to Boromir telling him to attack at first light of the fifth day if he receives the message. Even if Saruman is 99% Byzantine, Aragorn and Boromir can agree, because one messenger will have slipped through Saruman’s nets. <br/></p><p>It’s not perfect, because it relies on the assumption that Saruman isn’t fully Byzantine, but these types of practical workarounds are how most distributed systems solve the Two Generals Problem today.</p><h2>The Byzantine Generals Problem</h2><p><a href="https://en.wikipedia.org/wiki/Robert_Shostak" target="_blank">Robert Shostak</a> was the computer scientist who conceptualized and formalized the problem of coming to a consensus in spite of Byzantine faults. In 1982, together with <a href="https://en.wikipedia.org/wiki/Leslie_Lamport" target="_blank">Leslie Lamport</a> and Marshall Pease, he published a seminal paper in computer science, <a href="https://people.eecs.berkeley.edu/~luca/cs174/byzantine.pdf" target="_blank">The Byzantine Generals Problem</a>, that gave the problem its name (it was called the interactive consistency problem before). Their paper showed when and how you could solve this tough problem.<br/></p><p>The Two Generals Problem is impossible to solve perfectly because the network is Byzantine. But what if it’s not the network that’s Byzantine, but one of the nodes in the system. What if more than one node is corrupt and sends out different signals to the other nodes? How many nodes can get corrupted before the system produces a Byzantine failure? That’s the Byzantine Generals Problem.<br/></p><p>Let’s return to our Lord of the Rings example, but add one character: Faramir. Aragorn, Boromir, and Faramir want to attack Saruman’s tower, but they can only win the fight if all three attack at the same time. Saruman won’t intervene with their messages this time, but unfortunately Boromir has been converted. He is a traitor.<br/></p><p>Boromir intends to stop Aragorn and Faramir from agreeing. Conversely, Aragorn and Faramir want to come to a consensus. As a general rule, to solve the Byzantine Generals Problem, all loyal nodes need to agree on what one particular node says, regardless of whether that node is a traitor or not. <br/></p><p>In our example, consider Aragorn and Faramir are waiting for the orders of Boromir. The vile traitor he is, Boromir sends (attack) to Faramir and (stay) to Aragorn. Faramir wants to make sure he’s not being tricked and asks Aragorn what order Boromir sent him. Aragorn says he was ordered to stay. At this point, Faramir has two differing orders: (attack) from Boromir and (stay) from Aragorn. He cannot know who the traitor is and doesn’t know which order to follow.<br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb2886621846bb5ca1dec_bwAQZK1FzcqrrxpyARNc2JH0Y4yAeyhkOyfWnTiJb_wdxan43ZEwMZUwnsqvt9Vbg-piMqHu4MbePf1_odCmq3iIwV7UvA0jXJ0ROcZhxQQYcnuH9yPzQxB0kgoc2qXw2KO-77HP.jpeg" alt=""/></div><figcaption><em>Faramir cannot know who the traitor is and doesn’t know which order to follow</em></figcaption></figure><p>Now imagine Boromir doesn’t give the initial command, but Aragorn does. Aragorn sends (attack) to both other heroes. When Faramir checks in with Boromir, Boromir lies and says he’s been ordered to stay. Once again, Faramir is stuck. He cannot know who the traitor is and doesn’t know which order to follow.<br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb2889a0f0067655a6414_P2jE6lXm55f3hyPi51hiYonmdlGnkCDlyy3uhli5EL2xT_x-ReCEPx6ewOYGccJkF6Droq_BPGospq-VgArDVeTrNxTCWn8y9Cs-t3LVZ5G_NdKyVgmrFxX4Q7mk5ce_9Q77IL5S.jpeg" alt=""/></div><figcaption><em>Same problem</em></figcaption></figure><p>The conclusion is that you cannot solve the Byzantine Generals Problem if there are three generals and one of them is a traitor. Shostak, Lamport, and Pease concluded that the Byzantine Generals Problem is solvable if and only if more than two- thirds of all nodes are loyal (with non-encrypted messages, at least).<br/></p><p>If Gandalf joined the fight and Boromir was still a traitor, the loyal heroes could agree regardless of what Boromir said. He could say (attack) to Faramir and Aragorn, and (stay) to Gandalf, but any of the heroes could simply ask the others what they’ve been sent and follow the majority order (attack, in this case). <br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://uploads-ssl.webflow.com/5e8cabf5226ebd6d1c477f7d/5f8eb2885aa4c2d10cfccb4b_6g7en75yaycTPgEjDVbKTn_wwh9YSQf8ZWBeZDNQw-_6RmOaunOKwxJ7aiAsMMOfpKylcs8xMPkMFjDcHRFTL61BZahfoU5xra-2LTcXuntJMIcK7vKPyCEOzDnxvMWEdqFX2-A8.jpeg" alt=""/></div><figcaption>Faramir and Gandalf can simply follow majority orders to find consensus</figcaption></figure><h3>How Does a Blockchain Become Byzantine Fault Tolerant?</h3><p>All this is relevant for blockchain technology, because a blockchain is a decentralized system where all nodes need to agree on what one particular node said (the one that found the <a href="https://tdmoor.com/blog/understanding-blockchain-technology" target="_blank">key to the cryptographic puzzle</a>). A blockchain is Byzantine fault tolerant because of the consensus protocol it uses. <br/></p><p>A consensus protocol is a set of rules that incentives the right behavior and either doesn’t incentivize or punishes the wrong behavior. The two most popular consensus protocols in blockchain today are proof of work (PoW) and proof of stake (PoS). PoW is used in Bitcoin and Ethereum v1, while PoS is used in more modern blockchains such as <a href="https://near.org/" target="_blank">NEAR</a> and <a href="https://www.tdmoor.com/blog/understanding-eth2" target="_blank">Ethereum v2</a>. PoW requires nodes to solve a cryptographic puzzle by throwing a lot of computing power at it, while PoS requires nodes to stake a percentage of the blockchain’s coin in exchange for a chance of becoming a block creator. <br/></p><p>Both PoW and PoS are Byzantine fault tolerant because nodes will always be able to find agreement as long as more than two-thirds of the nodes are loyal. Combine this with other rules in the protocol that make it extremely hard to actually send false information to other nodes and you have extremely safe distributed technology.</p><h3>In Conclusion</h3><p>When nodes in a decentralized system need to come to an agreement, they must be protected against Byzantine faults. If the network between the nodes is what causes Byzantine faults, you cannot create a perfectly Byzantine fault tolerant system, although there are practical workarounds. If some of the nodes are causing Byzantine faults, there is a solution if and only if more than two-thirds of all nodes are working correctly.<br/></p><p>Blockchains are Byzantine fault tolerant through their consensus protocols. These protocols make it very hard to send wrong or confusing information to other nodes in the network. As long as more than two-thirds of all nodes work, these blockchains cannot be corrupted.<br/></p></div></div><footer id="footer" class="footer"><div class="w-container"><div class="text-block-2">Copyright © 2020 Thomas De Moor. All rights reserved.</div></div></footer></div><script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=5e849171e22116b8b837e679" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="https://uploads-ssl.webflow.com/5e849171e22116b8b837e679/js/webflow.61459fc63.js" type="text/javascript"></script><!--[if lte IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif]--></body></html>

